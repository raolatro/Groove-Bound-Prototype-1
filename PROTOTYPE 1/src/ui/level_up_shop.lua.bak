-- level_up_shop.lua
-- Handles the level-up shop UI, card display, and selection logic

local L = require("lib.loader")
local BlockGrid = require("src.ui.block_grid")
local Rarity = require("src.data.rarity")
local ItemDefs = require("src.data.item_defs")
local UI = require("config.ui")
local Config = require("config.settings")
local Event = require("lib.event")
local Debug = require("src.debug")

-- Local shorthand
local TUNING = Config.TUNING
local DEV = Config.DEV

-- Check if LevelUpShop has already been defined (for hot-reloading support)
local _LevelUpShop = LevelUpShop

-- Reset LevelUpShop to nil so we define it fresh
LevelUpShop = nil

-- Card generation helpers
local function findItemIndexById(items, id)
    for i, item in ipairs(items) do
        if item.id == id then
            return i
        end
    end
    return nil
end

-- Deep copy function for tables
local function table_copy(obj)
    if type(obj) ~= 'table' then return obj end
    local res = {}
    for k, v in pairs(obj) do res[table_copy(k)] = table_copy(v) end
    return res
end

-- The LevelUpShop module
LevelUpShop = {
    -- UI grid layout
    grid = nil,
    
    -- Current state
    isOpen = false,
    selectedIndex = 1,
    cards = {},
    
    -- References to other systems
    player = nil,
    weaponSystem = nil,
    passiveSystem = nil,
    
    -- Delayed opening
    pendingOpen = false,
    delayTimer = 0,
    openDelay = 0,
    
    -- Card layout constants
    cardWidth = 200,
    cardHeight = 300,
    cardPadding = 20,
    
    -- Background capture
    backgroundCapture = nil,
    blurRadius = 5,
    
    -- Transition effect
    transitionAlpha = 0
}

-- UI grid settings
LevelUpShop.layout = {
    -- Main grid dimensions
    rows = 5,
    cols = 5,
    
    -- Card positions (grid cells)
    cardPositions = {
        {2, 2}, -- Card 1 - left
        {3, 2}, -- Card 2 - middle
        {4, 2}  -- Card 3 - right
    },
    
    -- Button positions
    buttonPositions = {
        {2, 4}, -- Reroll button
        {4, 4}  -- Skip button
    }
}

-- Card colors based on rarity
LevelUpShop.colors = {
    background = {0.1, 0.1, 0.1, 0.95},
    selected = {1, 1, 1, 1},
    unselected = {0.6, 0.6, 0.6, 1},
    title = {1, 1, 1, 1},
    description = {0.8, 0.8, 0.8, 1},
    button = {0.2, 0.2, 0.4, 1},
    buttonHover = {0.3, 0.3, 0.5, 1},
    buttonText = {1, 1, 1, 1}
}

-- Initialize the shop
function LevelUpShop:new()
    local shop = table_copy(self)
    
    -- Create UI grid
    shop.grid = BlockGrid:new({
        rows = self.layout.rows,
        cols = self.layout.cols,
        cellWidth = (UI.GAME.w / self.layout.cols),
        cellHeight = (UI.GAME.h / self.layout.rows)
    })
    
    return shop
end

local L = require("lib.loader")
local BlockGrid = require("src.ui.block_grid")
local Rarity = require("src.data.rarity")
local ItemDefs = require("src.data.item_defs")
local UI = require("config.ui")
local Config = require("config.settings")
local Event = require("lib.event")
local Debug = require("src.debug")

-- Local shorthand
local TUNING = Config.TUNING
local DEV = Config.DEV

-- Check if LevelUpShop has already been defined (for hot-reloading support)
local _LevelUpShop = LevelUpShop

-- Reset LevelUpShop to nil so we define it fresh
LevelUpShop = nil

-- Define the module
local LevelUpShop = {
    -- Shop state
    isOpen = false,
    selectedIndex = 1,        -- Currently selected card/button (1-3 cards, 4=reroll, 5=skip)
    cards = {},               -- Array of card data
    blurCanvas = nil,         -- Canvas for background blur
    blurShader = nil,         -- Gaussian blur shader
    transitionAlpha = 0,      -- Alpha for fade in/out transitions
    
    -- References
    player = nil,             -- Reference to player
    levelUpSystem = nil,      -- Reference to level-up system
    weaponSystem = nil,       -- Reference to weapon system
    passiveSystem = nil,      -- Reference to passive system
    
    -- UI properties
    cardWidth = 180,
    cardHeight = 250,
    cardSpacing = 30,
    grid = nil,
    numCards = 3,
    
    -- Animation state
    pendingOpen = false,
    delayTimer = 0,
    openDelay = 0             -- Optional delay before opening
    
    -- No flash animation state anymore (removed)
}

-- Initialize the level-up shop
function LevelUpShop:init(player, levelUpSystem)
    -- Store references
    self.player = player
    self.levelUpSystem = levelUpSystem
    
    -- Get systems from the levelUpSystem if available
    if levelUpSystem then
        self.weaponSystem = levelUpSystem.weaponSystem
        self.passiveSystem = levelUpSystem.passiveSystem
        
        if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
            if self.weaponSystem then
                Debug.log("LevelUpShop: Received weapon system reference")
            else
                Debug.log("WARNING: LevelUpShop initialized without weapon system reference")
            end
        end
    end
    
    -- Create our own grid instance with metrics
    self.grid = {
        base = UI.GRID.base,
        blocksX = UI.GRID.blocksX,
        blocksY = UI.GRID.blocksY
    }
    
    -- Add methods to our grid instance
    function self.grid:getWidthInPixels(blocks)
        return blocks * self.base
    end
    
    function self.grid:getHeightInPixels(blocks)
        return blocks * self.base
    end
    
    -- Set card dimensions (4 blocks wide, 6 blocks tall)
    self.cardWidth = self.grid:getWidthInPixels(4)
    self.cardHeight = self.grid:getHeightInPixels(6)
    
    -- Use a simple approach for now - no shader or complex canvas operations
    -- This simplifies implementation and avoids potential compatibility issues
    self.useSimpleBackground = true
    
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        Debug.log("LevelUpShop: Initialized with simple background rendering")
    end
    
    return self
end

-- These functions have been removed as we no longer need the flash effect
-- Shop will be opened directly from LevelUpSystem:triggerLevelUp

-- Open the shop with items for selection
function LevelUpShop:open(player, weaponSystem, passiveSystem)
    -- STRICT VALIDATION: Ensure we have ALL required references
    if not player then
        Debug.log("ERROR: LevelUpShop:open called without player reference")
        return
    end
    
    if not weaponSystem then
        Debug.log("ERROR: LevelUpShop:open called without weaponSystem reference")
        return
    end
    
    if not passiveSystem then
        Debug.log("ERROR: LevelUpShop:open called without passiveSystem reference")
        return
    end
    
    -- Store system references
    self.player = player
    self.weaponSystem = weaponSystem
    self.passiveSystem = passiveSystem
    
    -- Log debug info about system references (always log this since it's critical)
    Debug.log("LevelUpShop: Set shop references to weapon and passive systems")
    
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        -- Advanced debug info
        local weaponCount = #weaponSystem.weapons
        local passiveCount = #passiveSystem.passives
        Debug.log("LevelUpShop: WeaponSystem has " .. weaponCount .. " weapons")
        Debug.log("LevelUpShop: PassiveSystem has " .. passiveCount .. " passives")
    end
    
    -- Reset state
    self.isOpen = true
    self.selectedIndex = 1
    self.cards = {}
    self.transitionAlpha = 1.0 -- Start fully visible, no transition
    
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        Debug.log("LevelUpShop:open - Opening shop with isOpen set to: " .. tostring(self.isOpen))
    end
    
    -- Build candidate pool of items
    local candidatePool = self:buildCandidatePool()
    
    -- Calculate weights based on player luck
    local weights = Rarity.computeWeights(player.luck)
    
    -- Ensure a balanced mix of new items and upgrades
    local newItems = {}
    local upgradeItems = {}
    
    -- Sort candidates into new and upgrade pools
    for i, item in ipairs(candidatePool) do
        local currentLevel = 0
        if item.type == "weapon" and self.weaponSystem then
            currentLevel = self.weaponSystem:getLevel(item.id)
        elseif item.type == "passive" and self.passiveSystem then
            currentLevel = self.passiveSystem:getLevel(item.id)
        else
            currentLevel = item.currentLevel or 0
        end
        
        if currentLevel == 0 then
            table.insert(newItems, {item = item, index = i})
        else
            table.insert(upgradeItems, {item = item, index = i})
        end
    end
    
    Debug.log("Shop candidate pools: " .. #newItems .. " new items, " .. #upgradeItems .. " upgrades")
    
    -- Add a minimum of one upgrade and one new item if available
    local cardsNeeded = TUNING.SHOP.NUM_CARDS
    local cardsAdded = 0
    
    -- Add one upgrade if available
    if #upgradeItems > 0 then
        local idx = love.math.random(#upgradeItems)
        local selection = upgradeItems[idx]
        local card = self:buildCard(selection.item)
        table.insert(self.cards, card)
        table.remove(upgradeItems, idx)
        cardsAdded = cardsAdded + 1
    end
    
    -- Add one new item if available
    if #newItems > 0 then
        local idx = love.math.random(#newItems)
        local selection = newItems[idx]
        local card = self:buildCard(selection.item)
        table.insert(self.cards, card)
        table.remove(newItems, idx)
        cardsAdded = cardsAdded + 1
    end
    
    -- Combine remaining items and pick at random
    local remainingItems = {}
    for _, item in ipairs(newItems) do
        table.insert(remainingItems, item)
    end
    for _, item in ipairs(upgradeItems) do
        table.insert(remainingItems, item)
    end
    
    -- Shuffle remaining items for randomness
    for i = #remainingItems, 2, -1 do
        local j = love.math.random(i)
        remainingItems[i], remainingItems[j] = remainingItems[j], remainingItems[i]
    end
    
    -- Fill remaining slots
    while cardsAdded < cardsNeeded and #remainingItems > 0 do
        local selection = table.remove(remainingItems)
        local card = self:buildCard(selection.item)
        table.insert(self.cards, card)
        cardsAdded = cardsAdded + 1
    end
    
    -- Safety check in case pool is empty
    if #candidatePool == 0 then
        Debug.log("WARNING: Candidate pool is empty! Creating fallback cards")
        
        -- Add fallback weapon
        table.insert(candidatePool, {
            id = "fallback_weapon",
            type = "weapon",
            displayName = "Emergency Weapon",
            description = "This weapon appears when the pool is empty.",
            currentLevel = 0,
            maxLevel = 3,
            rarity = "common"
        })
        
        -- Add fallback passive
        table.insert(candidatePool, {
            id = "fallback_passive",
            type = "passive",
            displayName = "Emergency Passive", 
            description = "This passive appears when the pool is empty.",
            currentLevel = 0,
            maxLevel = 3,
            rarity = "common"
        })
    end
    
    -- Get random candidates from the pool
    for i = 1, TUNING.SHOP.NUM_CARDS do
        -- Safety check for pool size
        if #candidatePool == 0 then
            Debug.log("WARNING: Not enough candidates for card " .. i)
            break
        end
        
        -- Pick a random candidate
        local randomIndex = love.math.random(1, #candidatePool)
        local candidate = candidatePool[randomIndex]
        
        -- Remove from the pool to avoid duplicates
        table.remove(candidatePool, randomIndex)
        
        -- Ensure candidate has an icon before building the card
        if not candidate.icon or type(candidate.icon) ~= "userdata" then
            candidate.icon = self:ensureItemIcon(candidate)
        end
        
        -- Build card data
        local card = self:buildCard(candidate)
        table.insert(self.cards, card)
        
        Debug.log("CARD CREATED: " .. card.type .. " '" .. card.id .. "' - " .. 
                  (card.isNew and "NEW" or ("Level " .. card.currentLevel .. " -> " .. card.nextLevel)))
    end
    
    -- Always log the final card count
    Debug.log("FINAL CARD COUNT: " .. #self.cards)
    
    -- Capture the current screen for blur background
    self:captureBackground()
    
    return self
end

-- Build the pool of candidate items that can be offered
function LevelUpShop:buildCandidatePool()
    local pool = {}
    
    Debug.log("START BUILDING CANDIDATE POOL")
    
    -- Check if we have item definitions available
    if not ItemDefs then
        Debug.log("ERROR: Cannot build shop - ItemDefs is nil")
        ItemDefs = require("config.item_defs") -- Try to load directly
    end
    
    if not ItemDefs or not ItemDefs.weapons or not ItemDefs.passives then
        Debug.log("CRITICAL: ItemDefs is invalid or incomplete")
        -- Create fallback definitions if missing
        ItemDefs = ItemDefs or {}
        ItemDefs.weapons = ItemDefs.weapons or {
            {id = "fallback_weapon", displayName = "Fallback Weapon", description = "Emergency weapon", maxLevel = 3, 
             icon = love.graphics.newImage("assets/items/weapon_basic.png")}
        }
        ItemDefs.passives = ItemDefs.passives or {
            {id = "fallback_passive", displayName = "Fallback Passive", description = "Emergency passive", maxLevel = 3,
             icon = love.graphics.newImage("assets/items/passive_basic.png")}
        }
    end
    
    -- Get player's current items and levels (with fallback logic)
    local playerItems = {}
    local hasWeaponSystem = (self.weaponSystem ~= nil)
    local hasPassiveSystem = (self.passiveSystem ~= nil)
    
    -- Log system availability
    Debug.log("LevelUpShop: Building with weapon system: " .. 
              (hasWeaponSystem and "YES" or "NO") .. ", passive system: " .. 
              (hasPassiveSystem and "YES" or "NO"))
    
    -- Always continue even if systems are missing - we'll use fallback values
    
    -- Add weapons from weaponSystem (if available)
    if hasWeaponSystem then
        Debug.log("LevelUpShop: Using weaponSystem reference to get current weapon levels")
        
        -- Map all existing weapons to their levels
        for _, weapon in ipairs(self.weaponSystem.weapons) do
            if weapon and weapon.id then
                playerItems[weapon.id] = weapon.level
                Debug.log("LevelUpShop: Found weapon '" .. weapon.id .. "' at level " .. weapon.level)
            end
        end
    else
        if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
            Debug.log("LevelUpShop: Cannot get weapon levels - weaponSystem is missing")
        end
    end
    
    -- Add passives from passiveSystem (if available)
    if hasPassiveSystem then
        Debug.log("LevelUpShop: Using passiveSystem reference to get current passive levels")
        
        -- Map all existing passives to their levels
        for _, passive in ipairs(self.passiveSystem.passives) do
            if passive and passive.id then
                playerItems[passive.id] = passive.level
                Debug.log("LevelUpShop: Found passive '" .. passive.id .. "' at level " .. passive.level)
            end
        end
    else
        if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
            Debug.log("LevelUpShop: Cannot get passive levels - passiveSystem is missing")
        end
    end
    
    -- Check all weapons
    if ItemDefs and ItemDefs.weapons then
        Debug.log("Processing " .. #ItemDefs.weapons .. " weapon definitions")
        
        for i, itemDef in ipairs(ItemDefs.weapons) do
            local currentLevel = playerItems[itemDef.id] or 0
            local maxLevel = itemDef.maxLevel or 5
            
            -- Create a copy of the item definition with its current level
            local item = table.copy(itemDef)
            item.currentLevel = currentLevel
            item.type = "weapon"
            
            -- Add to candidate pool
            table.insert(pool, item)
            
            Debug.log("Added weapon candidate #" .. i .. ": '" .. (item.id or "unknown") .. 
                      "' (level " .. currentLevel .. ")")
        end
    else
        Debug.log("ERROR: No weapon definitions available")
    end
    
    -- Check all passives
    if ItemDefs and ItemDefs.passives then
        Debug.log("Processing " .. #ItemDefs.passives .. " passive definitions")
        
        for i, itemDef in ipairs(ItemDefs.passives) do
            local currentLevel = playerItems[itemDef.id] or 0
            local maxLevel = itemDef.maxLevel or 5
            
            -- Create a copy of the item definition with its current level
            local item = table.copy(itemDef)
            item.currentLevel = currentLevel
            item.type = "passive"
            
            -- Add to candidate pool
            table.insert(pool, item)
            
            Debug.log("Added passive candidate #" .. i .. ": '" .. (item.id or "unknown") .. 
                      "' (level " .. currentLevel .. ")")
        end
    else
        Debug.log("ERROR: No passive definitions available")
    end
    
    -- Log the final pool size
    Debug.log("FINAL CANDIDATE POOL SIZE: " .. #pool)
    
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        Debug.log("LevelUpShop: Built candidate pool with " .. #pool .. " items")
        for i, item in ipairs(pool) do
            Debug.log(string.format("%d. %s (%s, level %d/%d)", i, item.displayName, item.rarity, item.currentLevel, item.maxLevel))
        end
    end
    
    return pool
end

-- Build card data for the given item
function LevelUpShop:buildCard(item)
    -- Get current level using the improved getLevel methods
    local currentLevel = 0
    
    -- If we have systems, get the accurate levels
    if item.type == "weapon" and self.weaponSystem then
        -- Use the new direct method to get exact level
        currentLevel = self.weaponSystem:getLevel(item.id)
        Debug.log("Card: weapon '" .. item.id .. "' is at level " .. currentLevel)
    elseif item.type == "passive" and self.passiveSystem then
        -- Use the new direct method to get exact level
        currentLevel = self.passiveSystem:getLevel(item.id)
        Debug.log("Card: passive '" .. item.id .. "' is at level " .. currentLevel)
    else
        -- Fallback to the item's own level property if available
        currentLevel = item.currentLevel or 0
        Debug.log("Using fallback level for '" .. item.id .. "': " .. currentLevel)
    end
    
    -- Determine if this is a new item or an upgrade
    local isNew = (currentLevel == 0)
    local nextLevel = currentLevel + 1
    
    -- Always log card building for easier debugging
    Debug.log("Building card for '" .. item.id .. "' - " .. 
              (isNew and "NEW" or ("Level " .. currentLevel .. " -> " .. nextLevel)))
    
    -- Make sure item has a valid icon
    if not item.icon or type(item.icon) ~= "userdata" then
        item.icon = self:ensureItemIcon(item)
    end
    
    -- Build effect summary for this level
    local summaryLine = ""
    if not isNew then
        -- Use levelUps field from item_defs.lua format
        if item.type == "weapon" then
            -- For weapons, levelUps is key-value pairs
            local levelEffect = {}
            
            -- Safely get weapon definition and level ups
            local weaponIdx = self:findItemIndexById(ItemDefs.weapons, item.id)
            local levelUps = {}
            
            -- Safety check to ensure the index is valid
            if weaponIdx and ItemDefs.weapons[weaponIdx] then
                levelUps = ItemDefs.weapons[weaponIdx].levelUps or {}
            else
                Debug.log("WARNING: Could not find weapon definition for ID: " .. tostring(item.id))
            end
            
            -- Process each level up statistic
            for stat, value in pairs(levelUps) do
                -- Safety check to ensure value is a string
                if type(value) ~= "string" then
                    Debug.log("WARNING: LevelUp value for " .. stat .. " is not a string: " .. tostring(value))
                    value = tostring(value)
                end
                
                -- Parse the value string, e.g., "+5%" or "+1"
                local val = tonumber(string.match(value, "[%+%-]?(%d+)") or "0")
                local isPercent = string.find(value, "%%") ~= nil
                
                if isPercent then
                    val = val / 100 -- Convert to decimal for percentage
                end
                
                levelEffect[stat] = val
            end
            
            summaryLine = Rarity.buildEffectSummary(levelEffect)
        elseif item.type == "passive" then
            -- For passives, effects is indexed by level
            local levelEffect = ItemDefs.passives[self:findItemIndexById(ItemDefs.passives, item.id)].effects[nextLevel]
            if levelEffect then
                summaryLine = Rarity.buildEffectSummary(levelEffect)
            end
        end
    end
    
    -- Return card data
    return {
        id = item.id,
        type = item.type,
        displayName = item.displayName,
        description = item.description,
        icon = item.icon,
        color = item.color,
        rarity = item.rarity,
        currentLevel = currentLevel,
        nextLevel = nextLevel,
        isNew = isNew,
        summaryLine = summaryLine
    }
end

-- Utility function to deep copy a table (ensuring we don't have reference issues)
function table.copy(obj)
    if type(obj) ~= 'table' then return obj end
    local res = {}
    for k, v in pairs(obj) do res[k] = table.copy(v) end
    return res
end

-- Helper function to find an item's index in a table by its ID
function LevelUpShop:findItemIndexById(itemTable, itemId)
    for i, item in ipairs(itemTable) do
        if item.id == itemId then
            return i
        end
    end
    return nil
end

-- Helper function to ensure an item has a valid icon
function LevelUpShop:ensureItemIcon(item)
    -- If the item already has a valid icon, return it
    if item.icon and type(item.icon) == "userdata" then
        return item.icon
    end
    
    -- Try multiple fallback approaches
    
    -- 1. Check if there's a default icon in assets based on item type
    local iconPaths = {
        weapon = {
            "assets/items/weapon_basic.png",
            "assets/weapons/basic.png",
            "assets/images/weapons/default.png"
        },
        passive = {
            "assets/items/passive_basic.png",
            "assets/passives/basic.png",
            "assets/images/passives/default.png"
        }
    }
    
    -- Try each possible path
    local paths = iconPaths[item.type] or iconPaths.weapon
    for _, path in ipairs(paths) do
        local success, icon = pcall(function() return love.graphics.newImage(path) end)
        if success then
            Debug.log("Loaded fallback icon for " .. item.id .. ": " .. path)
            return icon
        end
    end
    
    -- 2. If no image found, create a colored rectangle as last resort
    Debug.log("Creating placeholder icon for " .. item.id)
    local canvas = love.graphics.newCanvas(32, 32)
    love.graphics.setCanvas(canvas)
    
    -- Different colors for different item types
    if item.type == "weapon" then
        love.graphics.setColor(0.8, 0.2, 0.2, 1)  -- Red for weapons
    else
        love.graphics.setColor(0.2, 0.6, 0.8, 1)  -- Blue for passives
    end
    
    -- Draw filled rectangle with border
    love.graphics.rectangle("fill", 2, 2, 28, 28)
    love.graphics.setColor(1, 1, 1, 1)
    love.graphics.rectangle("line", 1, 1, 30, 30)
    
    -- Add text label
    love.graphics.setFont(love.graphics.newFont(10))
    local label = "?"
    if item.type == "weapon" then
        label = "W"
    else
        label = "P"
    end
    love.graphics.printf(label, 0, 11, 32, "center")
    
    -- Reset state
    love.graphics.setCanvas()
    love.graphics.setColor(1, 1, 1, 1)  -- Reset color
    
    return canvas
end

-- Capture the current screen for background (simplified)
function LevelUpShop:captureBackground()
    -- With the simplified approach, we don't need to capture anything
    -- This method is kept for API compatibility
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        Debug.log("LevelUpShop: Using simplified background approach")
    end
end

-- Draw the shop UI
function LevelUpShop:draw()
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        -- Debug.log("LevelUpShop:draw - isOpen: " .. tostring(self.isOpen))
    end
    
    -- If the shop isn't explicitly open, exit early
    if not self.isOpen then
        if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
            Debug.log("LevelUpShop:draw - Skipping draw, shop not open")
        end
        return
    end
    
    -- Safety check for player reference
    if not self.player then
        if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
            Debug.log("ERROR: LevelUpShop:draw - Missing player reference")
        end
        
        -- Try to continue anyway to maintain flow
        self:drawBackground()
        return
    end
    
    -- Draw darkened background to ensure shop stands out against game
    -- Use a more opaque background (0.95 opacity)
    love.graphics.setColor(0, 0, 0, 0.95)
    love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), love.graphics.getHeight())
    love.graphics.setColor(1, 1, 1, 1)
    
    -- Draw shop title
    self:drawTitle()
    
    -- Draw cards
    self:drawCards()
    
    -- Draw buttons
    self:drawButtons()
    
    -- Debug info
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        love.graphics.setColor(1, 1, 1, 1)
        love.graphics.print("Level-Up Shop (Selected: " .. self.selectedIndex .. ")", 10, 10)
        
        -- Add safety checks for player properties
        local playerLuck = self.player.luck or 0
        local playerCoins = self.player.coins or 0
        
        love.graphics.print("Player Luck: " .. playerLuck, 10, 30)
        love.graphics.print("Player Coins: " .. playerCoins, 10, 50)
    end
end

-- Draw the shop title
function LevelUpShop:drawTitle()
    -- Safety check - make sure we have player reference
    if not self.player then
        if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
            Debug.log("ERROR: LevelUpShop:drawTitle - No player reference")
        end
        return
    end
    
    local screenWidth = love.graphics.getWidth()
    local font = love.graphics.newFont(32)
    
    -- Save current font
    local currentFont = love.graphics.getFont()
    
    -- Set title font and color
    love.graphics.setFont(font)
    love.graphics.setColor(1, 1, 1, 1)
    
    -- Draw the level-up title using the level from the level-up system
    -- This is more accurate as it reflects the level-up system's tracking
    local playerLevel = self.playerLevel or (self.levelUpSystem and self.levelUpSystem.currentLevel) or 1
    local title = "Level Up! You reached level " .. playerLevel
    local subtitle = "Choose an upgrade:"
    
    -- Draw title and subtitle
    love.graphics.printf(title, 0, love.graphics.getHeight() * 0.15, screenWidth, "center")
    love.graphics.printf(subtitle, 0, love.graphics.getHeight() * 0.2, screenWidth, "center")
    
    -- Restore original font
    love.graphics.setFont(currentFont)
end

-- Draw the background (simplified approach)
function LevelUpShop:drawBackground()
    -- Draw a fully opaque black overlay with a slight transparency
    -- This ensures the shop is clearly visible against the game background
    love.graphics.setColor(0, 0, 0, 0.9)
    love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), love.graphics.getHeight())
    
    -- Reset color
    love.graphics.setColor(1, 1, 1, 1)
    
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        Debug.log("LevelUpShop:drawBackground - Drawing overlay")
    end
end

-- Draw the item cards
function LevelUpShop:drawCards()
    -- Calculate card positions
    local screenWidth = love.graphics.getWidth()
    local screenHeight = love.graphics.getHeight()
    local cardSpacing = self.grid:getWidthInPixels(1)
    local totalWidth = (#self.cards * self.cardWidth) + ((#self.cards - 1) * cardSpacing)
    local startX = (screenWidth - totalWidth) / 2
    local startY = screenHeight * 0.25
    
    -- Draw each card
    for i, card in ipairs(self.cards) do
        local x = startX + (i-1) * (self.cardWidth + cardSpacing)
        local y = startY
        
        -- Highlight selected card
        local isSelected = (self.selectedIndex == i)
        self:drawCard(card, x, y, isSelected)
    end
end

-- Draw a single card
function LevelUpShop:drawCard(card, x, y, isSelected)
    -- Get rarity color
    local rarityColor = Rarity.colors[card.rarity] or {0.7, 0.7, 0.7, 1.0}
    
    -- Border thickness adjustment for selected cards
    local borderThickness = isSelected and 4 or 2
    
    -- Draw card background
    love.graphics.setColor(0.1, 0.1, 0.1, 0.9)
    love.graphics.rectangle("fill", x, y, self.cardWidth, self.cardHeight, 10, 10)
    
    -- Draw rarity border
    love.graphics.setColor(rarityColor)
    love.graphics.setLineWidth(borderThickness)
    love.graphics.rectangle("line", x, y, self.cardWidth, self.cardHeight, 10, 10)
    
    -- Draw selection indicator if selected
    if isSelected then
        -- Draw pulsing arrow on the left side
        local arrowSize = self.grid:getWidthInPixels(1)
        local pulseScale = 0.8 + math.sin(love.timer.getTime() * 5) * 0.2
        local arrowX = x - arrowSize * 1.5
        local arrowY = y + self.cardHeight / 2
        
        love.graphics.setColor(1, 0.8, 0.2, 1.0) -- Yellow pulsing arrow
        love.graphics.polygon("fill", 
            arrowX, arrowY,
            arrowX - arrowSize * pulseScale, arrowY - arrowSize * 0.5 * pulseScale,
            arrowX - arrowSize * pulseScale, arrowY + arrowSize * 0.5 * pulseScale
        )
    end
    
    -- Draw item name
    love.graphics.setColor(1, 1, 1, 1)
    love.graphics.setFont(love.graphics.newFont(18))
    love.graphics.printf(card.displayName, x + 10, y + 20, self.cardWidth - 20, "center")
    
    -- Draw item icon placeholder
    local iconSize = self.grid:getWidthInPixels(2)
    local iconX = x + (self.cardWidth - iconSize) / 2
    local iconY = y + self.grid:getHeightInPixels(1.5)
    
    -- Draw colored icon background
    local itemColor = card.color or {1, 1, 1, 1}
    love.graphics.setColor(itemColor)
    love.graphics.rectangle("fill", iconX, iconY, iconSize, iconSize, 5, 5)
    
    -- Draw actual icon if available
    if card.icon then
        love.graphics.setColor(1, 1, 1, 1)
        love.graphics.draw(card.icon, iconX, iconY, 0, iconSize / card.icon:getWidth(), iconSize / card.icon:getHeight())
    end
    
    -- Draw NEW tag or level indicator
    local tagY = y + self.grid:getHeightInPixels(3.7)
    local tagWidth = self.grid:getWidthInPixels(2)
    local tagHeight = self.grid:getHeightInPixels(0.6)
    local tagX = x + (self.cardWidth - tagWidth) / 2
    
    -- Enhanced debug information for card levels
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP and isSelected then
        local debugX = x + self.cardWidth + 10
        local debugY = y + 10
        love.graphics.setColor(1, 1, 1, 0.8)
        love.graphics.setFont(love.graphics.newFont(10))
        local debugInfo = {
            "ID: " .. card.id,
            "Type: " .. card.type,
            "Current Level: " .. (card.currentLevel or 0),
            "Next Level: " .. card.nextLevel,
            "isNew: " .. tostring(card.isNew)
        }
        
        -- Add system reference info
        if card.type == "weapon" then
            local sysLevel = self.weaponSystem and self.weaponSystem:getLevel(card.id) or "nil"
            table.insert(debugInfo, "Weapon Sys Level: " .. sysLevel)
        elseif card.type == "passive" then
            local sysLevel = self.passiveSystem and self.passiveSystem:getLevel(card.id) or "nil"
            table.insert(debugInfo, "Passive Sys Level: " .. sysLevel)
        end
        
        -- Draw each line
        for i, line in ipairs(debugInfo) do
            love.graphics.print(line, debugX, debugY + (i-1) * 12)
        end
    end
    
    -- Draw appropriate badge based on item status
    if card.isNew then
        -- NEW badge for brand new items (green)
        love.graphics.setColor(0.2, 0.8, 0.2, 1.0) -- Green
        love.graphics.rectangle("fill", tagX, tagY, tagWidth, tagHeight, 5, 5)
        love.graphics.setColor(1, 1, 1, 1)
        love.graphics.setFont(love.graphics.newFont(14))
        love.graphics.printf("NEW", tagX, tagY + 5, tagWidth, "center")
    else
        -- Level-up badge for existing items (blue)
        love.graphics.setColor(0.2, 0.4, 0.8, 1.0) -- Blue for upgrades
        love.graphics.rectangle("fill", tagX, tagY, tagWidth, tagHeight, 5, 5)
        love.graphics.setColor(1, 1, 1, 1)
        love.graphics.setFont(love.graphics.newFont(14))
        -- Show precise level label
        love.graphics.printf("LV " .. card.nextLevel, tagX, tagY + 5, tagWidth, "center")
    end
    
    -- Draw effect summary line
    if card.summaryLine and card.summaryLine ~= "" then
        love.graphics.setColor(0.9, 0.9, 0.9, 1.0)
        love.graphics.setFont(love.graphics.newFont(12))
        love.graphics.printf(card.summaryLine, x + 10, tagY + tagHeight + 10, self.cardWidth - 20, "center")
    end
    
    -- Reset color
    love.graphics.setColor(1, 1, 1, 1)
end

-- Draw the buttons (Reroll, Skip)
function LevelUpShop:drawButtons()
    -- Constants for button layout
    local buttonHeight = self.grid:getHeightInPixels(1)
    local screenWidth = love.graphics.getWidth()
    local screenHeight = love.graphics.getHeight()
    
    -- Button positions
    local rerollWidth = self.grid:getWidthInPixels(4)
    local skipWidth = self.grid:getWidthInPixels(3)
    local spacing = self.grid:getWidthInPixels(1)
    local totalWidth = rerollWidth + spacing + skipWidth
    local startX = (screenWidth - totalWidth) / 2
    local buttonY = screenHeight * 0.65
    
    -- Draw REROLL button
    local rerollX = startX
    local isRerollSelected = (self.selectedIndex == #self.cards + 1)
    
    if isRerollSelected then
        -- Draw selection indicator
        local arrowSize = self.grid:getWidthInPixels(0.8)
        local pulseScale = 0.8 + math.sin(love.timer.getTime() * 5) * 0.2
        local arrowX = rerollX - arrowSize * 1.5
        local arrowY = buttonY + buttonHeight / 2
        
        love.graphics.setColor(1, 0.8, 0.2, 1.0) -- Yellow pulsing arrow
        love.graphics.polygon("fill", 
            arrowX, arrowY,
            arrowX - arrowSize * pulseScale, arrowY - arrowSize * 0.5 * pulseScale,
            arrowX - arrowSize * pulseScale, arrowY + arrowSize * 0.5 * pulseScale
        )
    end
    
    -- Button background
    love.graphics.setColor(0.2, 0.4, 0.8, isRerollSelected and 1.0 or 0.7)
    love.graphics.rectangle("fill", rerollX, buttonY, rerollWidth, buttonHeight, 5, 5)
    
    -- Button text
    love.graphics.setColor(1, 1, 1, 1)
    love.graphics.setFont(love.graphics.newFont(16))
    local rerollText = "REROLL"
    if TUNING.SHOP.REROLL_COST > 0 then
        rerollText = rerollText .. " (" .. TUNING.SHOP.REROLL_COST .. " coins)"
    end
    love.graphics.printf(rerollText, rerollX, buttonY + (buttonHeight - 16) / 2, rerollWidth, "center")
    
    -- Draw SKIP button
    local skipX = rerollX + rerollWidth + spacing
    local isSkipSelected = (self.selectedIndex == #self.cards + 2)
    
    if isSkipSelected then
        -- Draw selection indicator
        local arrowSize = self.grid:getWidthInPixels(0.8)
        local pulseScale = 0.8 + math.sin(love.timer.getTime() * 5) * 0.2
        local arrowX = skipX - arrowSize * 1.5
        local arrowY = buttonY + buttonHeight / 2
        
        love.graphics.setColor(1, 0.8, 0.2, 1.0) -- Yellow pulsing arrow
        love.graphics.polygon("fill", 
            arrowX, arrowY,
            arrowX - arrowSize * pulseScale, arrowY - arrowSize * 0.5 * pulseScale,
            arrowX - arrowSize * pulseScale, arrowY + arrowSize * 0.5 * pulseScale
        )
    end
    
    -- Button background
    love.graphics.setColor(0.5, 0.5, 0.5, isSkipSelected and 1.0 or 0.7)
    love.graphics.rectangle("fill", skipX, buttonY, skipWidth, buttonHeight, 5, 5)
    
    -- Button text
    love.graphics.setColor(1, 1, 1, 1)
    love.graphics.printf("SKIP", skipX, buttonY + (buttonHeight - 16) / 2, skipWidth, "center")
end

-- Update the shop UI and handle input
function LevelUpShop:update(dt)
    -- Handle delayed opening if set
    if self.pendingOpen then
        self.delayTimer = (self.delayTimer or 0) + dt
        
        -- When delay is over, open the shop
        if self.delayTimer >= (self.openDelay or 0) then
            self.pendingOpen = false
            
            -- CRITICAL: Ensure we have system references before opening
            if not self.player then
                Debug.log("ERROR: Cannot open shop - missing player reference")
                return
            end
            
            -- Get/verify system references directly from player if needed
            if not self.weaponSystem and self.player.weaponSystem then
                self.weaponSystem = self.player.weaponSystem
                Debug.log("LevelUpShop: Retrieved weaponSystem directly from player")
            end
            
            if not self.passiveSystem and self.player.passiveSystem then
                self.passiveSystem = self.player.passiveSystem
                Debug.log("LevelUpShop: Retrieved passiveSystem directly from player")
            end
            
            -- Pass all required system references to open
            self:open(self.player, self.weaponSystem, self.passiveSystem)
            
            -- Log system state after open
            if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
                Debug.log("LevelUpShop:update - Shop state after opening:")
                Debug.log("  isOpen: " .. tostring(self.isOpen))
                Debug.log("  Selected index: " .. tostring(self.selectedIndex)) 
                Debug.log("  Card count: " .. #self.cards)
            end
        end
    end
    
    -- Do nothing more if not fully open
    if not self.isOpen then
        return
    end

    -- Used for animations or other continuous updates while shop is open
    -- Update transition alpha
    self.transitionAlpha = math.min(1, self.transitionAlpha + dt * 3)
end

-- Handle keyboard input
function LevelUpShop:keypressed(key)
    if not self.isOpen then return false end
    
    if key == "left" or key == "a" then
        self:selectPrevious()
        return true
    elseif key == "right" or key == "d" then
        self:selectNext()
        return true
    elseif key == "return" or key == "space" then
        self:selectCurrent()
        return true
    elseif key == "escape" then
        self:skip()
        return true
    end
    
    return false
end

-- Handle gamepad input
function LevelUpShop:gamepadpressed(gamepad, button)
    if not self.isOpen then return false end
    
    -- Navigation controls
    if button == "dpleft" or button == "leftshoulder" then
        self:selectPrevious()
        return true
    elseif button == "dpright" or button == "rightshoulder" then
        self:selectNext()
        return true
    elseif button == "dpup" then
        -- If on buttons row, move to cards
        if self.selectedIndex > #self.cards then
            self.selectedIndex = 1
        end
        return true
    elseif button == "dpdown" then
        -- If on cards, move to buttons
        if self.selectedIndex <= #self.cards then
            self.selectedIndex = #self.cards + 1 -- Select reroll button
        end
        return true
    -- Action buttons
    elseif button == "a" or button == "y" or button == "triangle" then
        -- Use A (Xbox) / X (PS) or Y (Xbox) / Triangle (PS) for confirmation
        self:selectCurrent()
        return true
    elseif button == "b" then
        -- Use B (Xbox) / Circle (PS) to skip/cancel
        self:skip()
        return true
    end
    
    return false
end

-- Handle mouse click
function LevelUpShop:mousepressed(x, y, button)
    -- Only process clicks when the shop is open and fully initialized
    if not self.isOpen or button ~= 1 then return false end
    
    -- Additional safety check - ensure we have cards to show 
    if not self.cards or #self.cards == 0 then 
        if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
            Debug.log("LevelUpShop:mousepressed - No cards available, ignoring click")
        end
        return false 
    end
    
    -- Check if a card was clicked
    local screenWidth = love.graphics.getWidth()
    local screenHeight = love.graphics.getHeight()
    local cardSpacing = self.grid:getWidthInPixels(1)
    local totalWidth = (#self.cards * self.cardWidth) + ((#self.cards - 1) * cardSpacing)
    local startX = (screenWidth - totalWidth) / 2
    local startY = screenHeight * 0.25
    
    for i, _ in ipairs(self.cards) do
        local cardX = startX + (i-1) * (self.cardWidth + cardSpacing)
        local cardY = startY
        
        if x >= cardX and x <= cardX + self.cardWidth and
           y >= cardY and y <= cardY + self.cardHeight then
            self.selectedIndex = i
            self:selectCurrent()
            return true
        end
    end
    
    -- Check if reroll button was clicked
    local buttonHeight = self.grid:getHeightInPixels(1)
    local rerollWidth = self.grid:getWidthInPixels(4)
    local skipWidth = self.grid:getWidthInPixels(3)
    local spacing = self.grid:getWidthInPixels(1)
    local totalButtonWidth = rerollWidth + spacing + skipWidth
    local buttonStartX = (screenWidth - totalButtonWidth) / 2
    local buttonY = screenHeight * 0.65
    
    -- Reroll button
    local rerollX = buttonStartX
    if x >= rerollX and x <= rerollX + rerollWidth and
       y >= buttonY and y <= buttonY + buttonHeight then
        self.selectedIndex = #self.cards + 1
        self:selectCurrent()
        return true
    end
    
    -- Skip button
    local skipX = rerollX + rerollWidth + spacing
    if x >= skipX and x <= skipX + skipWidth and
       y >= buttonY and y <= buttonY + buttonHeight then
        self.selectedIndex = #self.cards + 2
        self:selectCurrent()
        return true
    end
    
    return false
end

-- Select the previous item
function LevelUpShop:selectPrevious()
    self.selectedIndex = self.selectedIndex - 1
    if self.selectedIndex < 1 then
        self.selectedIndex = #self.cards + 2 -- Wrap to the Skip button
    end
end

-- Select the next item
function LevelUpShop:selectNext()
    self.selectedIndex = self.selectedIndex + 1
    if self.selectedIndex > #self.cards + 2 then
        self.selectedIndex = 1 -- Wrap to the first card
    end
end

-- Select the current item
function LevelUpShop:selectCurrent()
    if self.selectedIndex <= #self.cards then
        -- Card selected
        self:selectCard(self.selectedIndex)
    elseif self.selectedIndex == #self.cards + 1 then
        -- Reroll button
        self:reroll()
    else
        -- Skip button
        self:skip()
    end
end

-- Handle card selection
function LevelUpShop:selectCard(index)
    -- Validate card selection
    if not self.cards or not self.cards[index] then 
        Debug.log("ERROR: LevelUpShop:selectCard - Invalid card or index: " .. tostring(index))
        return 
    end
    
    local card = self.cards[index]
    local itemId = card.id
    local itemType = card.type
    
    -- Always log selection for debugging
    Debug.log("PLAYER SELECTED: " .. itemType .. " '" .. itemId .. "' (" .. 
              (card.isNew and "NEW" or ("Level " .. (card.nextLevel-1) .. " -> " .. card.nextLevel)) .. ")")
    
    -- Apply the selection with the new addOrUpgrade methods
    if itemType == "weapon" then
        -- Use the new unified method for weapons
        if self.weaponSystem then
            -- Get the slot index for the weapon (new or existing)
            local slotIndex = self.weaponSystem:addOrUpgrade(itemId)
            
            -- Activate all weapons to start firing immediately
            self.weaponSystem:activateAll()
            
            Debug.log("Weapon '" .. itemId .. "' added/upgraded in slot " .. (slotIndex or "?") .. 
                      " and activated for immediate firing")
            
            -- Find and refresh the inventory UI if present
            if self.player and self.player.inventoryUI then
                self.player.inventoryUI:refresh()
                Debug.log("Refreshed inventory UI after weapon change")
            end
            
            -- Dispatch appropriate event
            if card.isNew then
                Event.dispatch("PLAYER_ITEM_GAINED", {id = itemId, type = "weapon", level = 1})
            else
                Event.dispatch("PLAYER_ITEM_LEVELED", {id = itemId, type = "weapon", level = card.nextLevel})
            end
        else
            Debug.log("ERROR: Cannot add/upgrade weapon - missing weaponSystem reference")
        end
    elseif itemType == "passive" then
        -- Use the new unified method for passives with error protection
        if self.passiveSystem then
            -- Add or upgrade the passive with pcall for safety
            local success, result = pcall(function()
                return self.passiveSystem:addOrUpgrade(itemId)
            end)
            
            if not success then
                -- Log the error and try fallback method
                Debug.log("ERROR during passive selection: " .. tostring(result))
                
                -- Try direct method as fallback
                if card.isNew then
                    -- Try to add directly
                    self.passiveSystem:addPassive(itemId)
                    Debug.log("Fallback: Added new passive " .. itemId .. " directly")
                else
                    -- Try to find and manually upgrade
                    for i, passive in ipairs(self.passiveSystem.passives) do
                        if passive.id == itemId then
                            passive.level = passive.level + 1
                            Debug.log("Fallback: Manually upgraded passive " .. itemId .. " to level " .. passive.level)
                            break
                        end
                    end
                end
            else
                Debug.log("Successfully added/upgraded passive " .. itemId)
            end
            
            -- Make sure to recalculate buff effects
            if type(self.passiveSystem.calculateCombinedBuffs) == "function" then
                self.passiveSystem:calculateCombinedBuffs()
            end
            
            -- Find and refresh the buffs UI if present
            if self.player and self.player.buffsUI then
                self.player.buffsUI:refresh()
                Debug.log("Refreshed buffs UI after passive change")
            end
            
            -- Dispatch appropriate event
            if card.isNew then
                Event.dispatch("PLAYER_BUFF_GAINED", {id = itemId, level = 1})
            else
                Event.dispatch("PLAYER_BUFF_LEVELED", {id = itemId, level = card.nextLevel})
            end
        else
            Debug.log("ERROR: Cannot add/upgrade passive - missing passiveSystem reference")
        end
    end
    
    -- Broadcast a general item change event for any listeners
    Event.dispatch("PLAYER_ITEMS_CHANGED", {})
    
    -- Close shop and resume gameplay
    self:close()
end

-- Handle reroll
function LevelUpShop:reroll()
    -- Always log reroll attempt
    Debug.log("LevelUpShop: Attempting to reroll shop")
    
    -- Safety check on player reference
    if not self.player then
        Debug.log("ERROR: Cannot reroll - missing player reference")
        return
    end
    
    -- Check if we need to enforce coin cost
    local rerollCost = TUNING.SHOP.REROLL_COST or 0
    if rerollCost > 0 then
        -- Safety check for player.coins property
        if not self.player.coins then
            Debug.log("ERROR: Player has no coins property for reroll cost")
            self.player.coins = rerollCost -- Create property with minimum needed
        end
        
        -- Check if player has enough coins
        if self.player.coins < rerollCost then
            Debug.log("Not enough coins to reroll: " .. self.player.coins .. "/" .. rerollCost)
            -- Show feedback to player
            -- TODO: Add visual feedback for insufficient coins
            return
        end
        
        -- Deduct coins
        self.player.coins = self.player.coins - rerollCost
        Debug.log("Deducted " .. rerollCost .. " coins for reroll, remaining: " .. self.player.coins)
    end
    
    -- Clear current cards
    self.cards = {}
    
    -- Build new candidate pool with pcall protection
    Debug.log("Rebuilding candidate pool for reroll")
    local success, candidatePool = pcall(function()
        return self:buildCandidatePool()
    end)
    
    if not success then
        Debug.log("ERROR building candidate pool: " .. tostring(candidatePool))
        -- Create emergency pool for fallback
        candidatePool = self:createEmergencyPool()
    end
    
    -- Ensure candidate pool is valid
    if not candidatePool or type(candidatePool) ~= "table" then
        Debug.log("ERROR: Invalid candidate pool after reroll")
        candidatePool = self:createEmergencyPool()
    end
    
    -- Create new set of cards
    self:generateCardsFromPool(candidatePool)
    
    -- Refresh shop display
    self.selectedIndex = 1
    Debug.log("Reroll complete, generated " .. #self.cards .. " new cards")
    
    -- No need to re-open shop, just refresh the cards
    end
end

-- Create an emergency pool of items when normal pool creation fails
function LevelUpShop:createEmergencyPool()
    Debug.log("Creating emergency item pool")
    local pool = {}
    
    -- Add fallback weapon
    table.insert(pool, {
        id = "pistol_weapon",
        type = "weapon",
        displayName = "Emergency Pistol",
        description = "Emergency fallback weapon.",
        currentLevel = 0,
        maxLevel = 3,
        rarity = "common"
    })
    
    -- Add fallback passive
    table.insert(pool, {
        id = "speed_passive",
        type = "passive",
        displayName = "Emergency Speed", 
        description = "Emergency fallback passive.",
        currentLevel = 0,
        maxLevel = 3,
        rarity = "common"
    })
    
    Debug.log("Created emergency pool with " .. #pool .. " items")
    return pool
end

-- Generate cards from a candidate pool
function LevelUpShop:generateCardsFromPool(candidatePool)
    Debug.log("Generating cards from pool of " .. #candidatePool .. " candidates")
    
    -- Make sure we have a valid pool
    if not candidatePool or #candidatePool == 0 then
        Debug.log("ERROR: Empty candidate pool, creating emergency items")
        candidatePool = self:createEmergencyPool()
    end
    
    -- Ensure a balanced mix of new items and upgrades
    local newItems = {}
    local upgradeItems = {}
    
    -- Sort candidates into new and upgrade pools
    for i, item in ipairs(candidatePool) do
        local currentLevel = 0
        if item.type == "weapon" and self.weaponSystem then
            currentLevel = self.weaponSystem:getLevel(item.id)
        elseif item.type == "passive" and self.passiveSystem then
            currentLevel = self.passiveSystem:getLevel(item.id)
        else
            currentLevel = item.currentLevel or 0
        end
        
        if currentLevel == 0 then
            table.insert(newItems, {item = item, index = i})
        else
            table.insert(upgradeItems, {item = item, index = i})
        end
    end
    
    Debug.log("Shop candidate pools: " .. #newItems .. " new items, " .. #upgradeItems .. " upgrades")
    
    -- Add a minimum of one upgrade and one new item if available
    local cardsNeeded = TUNING.SHOP.NUM_CARDS
    local cardsAdded = 0
    
    -- Add one upgrade if available
    if #upgradeItems > 0 then
        local idx = love.math.random(#upgradeItems)
        local selection = upgradeItems[idx]
        local card = self:buildCard(selection.item)
        table.insert(self.cards, card)
        table.remove(upgradeItems, idx)
        cardsAdded = cardsAdded + 1
    end
    
    -- Add one new item if available
    if #newItems > 0 then
        local idx = love.math.random(#newItems)
        local selection = newItems[idx]
        local card = self:buildCard(selection.item)
        table.insert(self.cards, card)
        table.remove(newItems, idx)
        cardsAdded = cardsAdded + 1
    end
    
    -- Combine remaining items and pick at random
    local remainingItems = {}
    for _, item in ipairs(newItems) do
        table.insert(remainingItems, item)
    end
    for _, item in ipairs(upgradeItems) do
        table.insert(remainingItems, item)
    end
    
    -- Shuffle remaining items for randomness
    for i = #remainingItems, 2, -1 do
        local j = love.math.random(i)
        remainingItems[i], remainingItems[j] = remainingItems[j], remainingItems[i]
    end
    
    -- Fill remaining slots
    while cardsAdded < cardsNeeded and #remainingItems > 0 do
        local selection = table.remove(remainingItems)
        local card = self:buildCard(selection.item)
        table.insert(self.cards, card)
        cardsAdded = cardsAdded + 1
    end
    
    -- Safety check - ensure we have at least one card
    if #self.cards == 0 then
        Debug.log("WARNING: No cards generated, adding emergency card")
        local emergencyItem = {
            id = "emergency_item",
            type = math.random() > 0.5 and "weapon" or "passive",
            displayName = "Emergency Item",
            description = "This item appears when no other items can be generated.",
            currentLevel = 0,
            maxLevel = 3,
            rarity = "common"
        }
        
        local card = self:buildCard(emergencyItem)
        table.insert(self.cards, card)
    end
    
    Debug.log("Generated " .. #self.cards .. " cards for shop")
end

-- Handle skip
function LevelUpShop:skip()
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        Debug.log("LevelUpShop: Skipped selection")
    end
    
    -- Close shop and resume gameplay
    self:close()
end

-- Close the shop
function LevelUpShop:close()
    -- Set shop state to closed
    self.isOpen = false
    
    -- Clear card data to prevent memory issues
    self.cards = {}
    
    -- Resume gameplay by dispatching the close event
    -- This will trigger the game to unpause
    Event.dispatch("LEVEL_UP_SHOP_CLOSED", {})
    
    if DEV.DEBUG_MASTER and DEV.DEBUG_LEVEL_UP then
        Debug.log("LevelUpShop: Closed and dispatched LEVEL_UP_SHOP_CLOSED event")
    end
end

-- Return the module
return LevelUpShop
